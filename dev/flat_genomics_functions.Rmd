---
title: "flat_genomics_functions.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Plotting

## Manhattan plots

The `gg_manhattan_df` function is used to create Manhattan plots. This function can optionally annotated the plot with additional information (eg. gene name, rsid) by using the `annotation_df` amd `label_col` arguments.
    
```{r function-gg_manhattan_df}
#' Create a Manhattan Plot
#'
#' This function is a wrapper around `ggfastman::fast_manhattan` which allows for the creation of a Manhattan plot from a dataframe containing GWAS summary statistics.
#'
#' @param sumstats_df Dataframe containing GWAS summary statistics
#' @param chr_col Name of chromosome column
#' @param pos_col Name of position column
#' @param pval_col Name of p-value column
#' @param annotation_df Optional dataframe containing chromosome, position, and annotation labels
#' @param label_col Name of column in `annotation_df` containing annotations to include on the plot
#' @param build (string) One of "hg18", "hg19", or "hg38" (passed to `ggfastman`)
#' @param color1 (string) Color for odd-numbered chromosomes (passed to `ggfastman`)
#' @param color2 (string) Color for even-numbered chromosomes (passed to `ggfastman`)
#' @param speed (string) One of "slow", "fast", or "ultrafast"; passed to `ggfastman` to control plotting speed
#' @param ... Passed to `ggfastman::fast_manhattan`
#'
#' @return A ggplot2 object
#' @export
#' @import dplyr ggplot2
#' @concept genomics

gg_manhattan_df <- function(sumstats_df, annotation_df = NULL, chr_col = chromosome, pos_col = position, pval_col = p_value, label_col = gene, build = "hg19", color1 = "#045ea7", color2 = "#82afd3", speed = "slow", ...) {
  if (!is.null((annotation_df))) {
    df <- sumstats_df %>%
      select(chr = {{ chr_col }}, pos = {{ pos_col }}, pvalue = {{ pval_col }}) %>%
      filter(pvalue < 0.001) %>%
      collect() %>%
      as_tibble() %>%
      mutate(across(.cols = everything(), as.numeric)) %>%
      tidyr::drop_na() %>%
      left_join(annotation_df %>% select(chr = {{ chr_col }}, pos = {{ pos_col }}, label = {{ label_col }})) %>%
      mutate(highlight = case_when(
        pvalue < 5e-8 ~ "#990000",
        TRUE ~ NA_character_
      ))
  } else {
    df <- sumstats_df %>%
      select(chr = {{ chr_col }}, pos = {{ pos_col }}, pvalue = {{ pval_col }}) %>%
      filter(pvalue < 0.001) %>%
      collect() %>%
      as_tibble() %>%
      mutate(across(.cols = everything(), as.numeric)) %>%
      tidyr::drop_na() %>%
      mutate(highlight = case_when(
        pvalue < 5e-8 ~ "#990000",
        TRUE ~ NA_character_
      ))
  }

  cli::cli_alert_info("Creating Manhattan Plot")
  if (!is.null((annotation_df))) {
    max_log10_p <- -log10(min(df$pvalue))

    plot <- df %>%
      ggfastman::fast_manhattan(
        build = build,
        color1 = color1,
        color2 = color2,
        pointsize = pointsize,
        speed = speed,
        ...
      ) +
      geom_hline(yintercept = -log10(5e-8), linetype = "dotted") +
      ggrepel::geom_text_repel(
        data = . %>%
          filter(!is.na(label)),
        aes(label = label),
        color = "black",
        force_pull = 0, # do not pull toward data points
        nudge_y = 10,
        direction = "x",
        angle = 90,
        hjust = 0,
        segment.size = 0.2,
        segment.curvature = -1e-20,
        segment.angle = 175,
        ylim = c(max_log10_p + 10, NA),
        max.overlaps = 50
      )
  } else {
    plot <- df %>%
      ggfastman::fast_manhattan(
        build = build,
        color1 = color1,
        color2 = color2,
        pointsize = pointsize,
        speed = speed,
        ...
      ) +
      geom_hline(yintercept = -log10(5e-8), linetype = "dotted")
  }

  plot <- plot +
    ggplot2::scale_y_continuous(expand = expansion(mult = c(0.01, 0.30)), name = "-log<sub>10</sub>(p-value)") +
    theme_bw(base_size = 16) +
    theme(
      panel.grid = element_blank(),
      axis.title.y = ggtext::element_markdown()
    )

  return(plot)
}
```
  
```{r example-gg_manhattan_df}
#' \dontrun{
#' gg_manhattan_df()
#' }
```
  
```{r tests-gg_manhattan_df}
test_that("gg_manhattan_df works", {
  expect_true(inherits(gg_manhattan_df, "function"))
})

test_that("gg_manhattan_df returns a ggplot object", {
  locus_df <- tibble(position = 1:100) %>%
    tidyr::crossing(chromosome = 1:22) %>%
    mutate(label = "Test")

  plot_res <- tibble(position = sample.int(1000, 100)) %>%
    tidyr::crossing(chromosome = 1:22) %>%
    rowwise() %>%
    mutate(p_value = runif(1, min = 1/1e5, max = 0.99)) %>%
    gg_manhattan_df(chr_col = chromosome, pos_col = position, pval_col = p_value)
  expect_s3_class(plot_res, "ggplot")

  plot_res <- tibble(position = 1:100) %>%
    tidyr::crossing(chromosome = 1:22) %>%
    rowwise() %>%
    mutate(p_value = runif(1, min = 1/1e5, max = 0.99)) %>%
    gg_manhattan_df(chr_col = chromosome, pos_col = position, pval_col = p_value, annotation_df = locus_df, label_col = label)
  expect_s3_class(plot_res, "ggplot")
})
```

  
## QQ plots

The `gg_qq_df` function can be used to generate a qq plot to visually evaluate for test statistic inflation, and calculate lambda GC to quantify any inflation.
    
```{r function-gg_qq_df}
#' Create a QQ plot
#'
#' This function is a wrapper around `ggfastman::fast_qq` which allows for the creation of a QQ plot from a dataframe containing GWAS summary statistics.
#'
#' @param sumstats_df Dataframe containing GWAS summary statistics
#' @param pval_col Name of p-value column
#' @param ... Passed to `ggfastman::fast_qq`
#'
#' @return A ggplot2 object
#'
#' @export
#' @import dplyr ggplot2
#' @concept genomics

gg_qq_df <- function(sumstats_df, pval_col = p_value, ...) {
  df <- sumstats_df %>%
    select(pvalue = {{ pval_col }}) %>%
    collect() %>%
    as_tibble() %>%
    mutate(across(.cols = everything(), as.numeric)) %>%
    pull(pvalue)

  cli::cli_alert_info("Creating QQ Plot")
  plot <- df %>%
    ggfastman::fast_qq(...)

  return(plot)
}
```
  
```{r example-gg_qq_df}
#' \dontrun{
#' gg_qq_df()
#' }
```
  
```{r tests-gg_qq_df}
test_that("gg_qq_df works", {
  expect_true(inherits(gg_qq_df, "function"))
})

test_that("gg_qq_df returns a ggplot object", {
  plot_res <- tibble(pval = runif(1000)) %>%
    gg_qq_df(pval_col = pval)
  expect_s3_class(plot_res, "ggplot")
})
```
  
# Annotation

## Add rsids

This function can be used rapidly add rsids to GWAS summary statistics by chromosome:position.
    
```{r function-annotate_rsids}
#' Annotate a dataframe containing genomic coordinates with rsids
#' 
#' This function can be used rapidly add rsids to GWAS summary statistics or any other dataframe containing genomic coordinates (eg. chromosome and position). This is a rapid function that does not explicitly account for differences in variants at each position, strand flips, etc.)
#' 
#' @param df Dataframe containing genomic coordinates to annotate with rsid
#' @param dbSNP Bioconductor object containing SNP locations and alleles to be used for annotation (default: `SNPlocs.Hsapiens.dbSNP144.GRCh37::SNPlocs.Hsapiens.dbSNP144.GRCh37`)
#' @param chrom_col Chromosome column 
#' @param pos_col Position column
#'
#' @return
#' 
#' @export
#' @concept genomics 

annotate_rsids <- function(df, dbSNP = SNPlocs.Hsapiens.dbSNP144.GRCh37::SNPlocs.Hsapiens.dbSNP144.GRCh37, chrom_col = Chromosome, pos_col = Position) {
  if (sum(stringr::str_detect(names(df), "rsid")) > 0) {
    cli::cli_abort("A column named 'rsid' is already present")
  }

  df <- df %>%
    dplyr::rename(chrom = {{ chrom_col }}) %>%
    dplyr::mutate(chrom = as.character(chrom)) %>%
    # mutate(chrom = glue::glue("{chrom}")) %>%
    dplyr::rename(start = {{ pos_col }}) %>%
    dplyr::mutate(end = start)

  # return(df)

  df_annotated <- df %>%
    dplyr::group_split(chrom) %>%
    purrr::map_dfr(function(df) {
      chrom <- df$chrom[1]

      cli::cli_alert_info("Annotating chromosome {chrom}")

      df_granges <- df %>%
        GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = TRUE, starts.in.df.are.0based = FALSE)

      snps_granges <- BSgenome::snpsByOverlaps(dbSNP, df_granges) %>%
        unique()

      plyranges::join_overlap_left_directed(df_granges, snps_granges) %>%
        as.data.frame() %>%
        mutate(seqnames = as.character(seqnames))
    })

  df_annotated %>%
    dplyr::rename(
      {{ chrom_col }} := seqnames,
      {{ pos_col }} := start
    ) %>%
    # dplyr::mutate({{ chr_col }} := as.numeric({{ chr_col }})) %>%
    # dplyr::mutate({{ pos_col }} := as.numeric({{ pos_col }})) %>%
    dplyr::rename(rsid = RefSNP_id) %>%
    dplyr::select(-end, -width, -strand, -alleles_as_ambig) %>%
    dplyr::select(rsid, everything()) %>%
    readr::type_convert(col_types = readr::cols())
}
```
  
```{r example-annotate_rsids}
#' \dontrun{
#' annotate_rsids()
#' }
```
  
```{r tests-annotate_rsids}
test_that("annotate_rsids works", {
  expect_true(inherits(annotate_rsids, "function")) 
})

test_that("annotate_rsids returns a tibble", {
  df <- tibble(Chromosome = 1) %>%
    tidyr::crossing(Position = 1e4:1e5)
  rsids_res <- annotate_rsids(df)
  expect_s3_class(rsids_res, "data.frame")
})
```
  
# METAL

## Configure METAL
    
```{r function-metal_config}
#' Create a configuration file for METAL
#' 
#' This function can be used to generate a configuration for METAL, a tool for performing meta-analysis of GWAS summary statistics <https://github.com/statgen/METAL>. The file created by this function can be used to run a meta-analysis. Details of the arguments to METAL are described in the METAL documentation: <https://genome.sph.umich.edu/wiki/METAL_Documentation>.
#' 
#' @param config_name (string) Name of the configuration
#' @param output_dir (path) Path to output directory where GWAS meta-analysis data should be stored
#' @param study_files (list) List of paths to summary statistics that should be included in the GWAS
#' @param SCHEME (string) Either "SAMPLESIZE" or "STDERR" (default), corresponding to the METAL analysis scheme
#' @param AVERAGEFREQ (string) Either "ON" (default) or "OFF", allowing METAL to report the mean effect allele frequency across files
#' @param MINMAXFREQ (string) Either "ON" (default) or "OFF", allowing METAL to report the min/max effect allele frequency across files
#' @param TRACKPOSITIONS (string) Either "ON" (default) or "OFF", allowing METAL to report chromosome/position in the output
#' @param MARKERLABEL (string) Column containing unique markers to analyze (this column must be named the same across all input files)
#' @param CHROMOSOMELABEL (string) Column containing chromosomes (this column must be named the same across all input files)
#' @param POSITIONLABEL (string) Column containing genomic positions (this column must be named the same across all input files)
#' @param EFFECT_ALLELE (string) Column containing effect alleles (this column must be named the same across all input files)
#' @param OTHER_ALLELE (string) Column containing non-effect alleles (this column must be named the same across all input files)
#' @param EFFECTLABEL (string) Column containing effect sizes corresponding to the effect allele (this column must be named the same across all input files)
#' @param STDERR (string) Column containing standard errors fo the effect estimate (this column must be named the same across all input files)
#' @param FREQLABEL (string) Column containing effect allele frequencies (this column must be named the same across all input files)
#' @param NCASE (string) Column containing number of cases (this column must be named the same across all input files)
#' @param NCONTROL (string) Column containing number of controls (this column must be named the same across all input files)
#' @param SAMPLESIZE (string) Column containing total samplesize (this column must be named the same across all input files)
#'
#' @return
#' @concept genomics
#' @export

metal_config <- function(config_name, output_dir, study_files, SCHEME = "STDERR", AVERAGEFREQ = "ON", MINMAXFREQ = "OFF", TRACKPOSITIONS = "ON", MARKERLABEL = "MARKER", CHROMOSOMELABEL = "CHROM", POSITIONLABEL = "POS", EFFECT_ALLELE = "EFFECT_ALLELE", OTHER_ALLELE = "OTHER_ALLELE", EFFECTLABEL = "BETA", STDERR = "SE", FREQLABEL = "EAF", NCASE = "N_CASE", NCONTROL = "N_CONTROL", SAMPLESIZE = "N") {
  
  fs::dir_create(output_dir, recurse = TRUE)

  config_outfile <- fs::path(output_dir, paste0(config_name, "_metal-config.txt"))
  meta_outfile <- fs::path(normalizePath(output_dir), config_name)

  study_files <- paste0(glue::glue("PROCESS {normalizePath(study_files)}"), collapse = "\n")

  config_text <- glue::glue(
    "SCHEME {SCHEME}
    AVERAGEFREQ {AVERAGEFREQ}
    MINMAXFREQ {MINMAXFREQ}
    TRACKPOSITIONs {TRACKPOSITIONS}
    MARKERLABEL {MARKERLABEL}
    CHROMOSOMELABEL {CHROMOSOMELABEL}
    POSITIONLABEL {POSITIONLABEL}
    ALLELELABELS {EFFECT_ALLELE} {OTHER_ALLELE}
    EFFECTLABEL {EFFECTLABEL}
    STDERR {STDERR}
    FREQLABEL {FREQLABEL}
    
    CUSTOMVARIABLE NCASE
    LABEL NCASE as {NCASE}
    
    CUSTOMVARIABLE NCONTROL
    LABEL NCONTROL as {NCONTROL}
    
    CUSTOMVARIABLE SAMPLESIZE
    LABEL SAMPLESIZE as {SAMPLESIZE}
    
    {study_files}
    
    OUTFILE {meta_outfile}_metal- .txt
    ANALYZE HETEROGENEITY
    
    QUIT
    "
  )

  readr::write_lines(x = config_text, file = config_outfile)

  return(config_outfile)
}
```
  
```{r example-metal_config}
#' \dontrun{
#' metal_config()
#' }
```
  
```{r tests-metal_config}
test_that("metal_config works", {
  expect_true(inherits(metal_config, "function")) 
})
```

## Run METAL
    
```{r function-metal_run}
#' Use METAL to run a GWAS meta-analysis
#' 
#' This function is a wrapper for METAL, a tool for performing meta-analysis of GWAS summary statistics <https://github.com/statgen/METAL>. Details of the arguments to METAL are described in the METAL documentation: <https://genome.sph.umich.edu/wiki/METAL_Documentation>.
#' 
#' @param config_file (path) Path to a METAL configuration file (this can be generated using [levinmisc::metal_config()])
#' @param metal_path (path) Path to the METAL binary
#'
#' @return Path to .gzipped meta-analysis summary statistics
#' @concept genomics
#' @export

metal_run <- function(config_file, metal_path) {
  metal_path <- normalizePath(metal_path)
  config_file <- normalizePath(config_file)

  processx::run(metal_path, args = config_file)
  output_file <- str_replace(config_file, "-config.txt", "-1.txt")

  processx::run("gzip", c("-f", output_file))

  output_file <- str_replace(output_file, ".txt", ".txt.gz")

  return(output_file)
}
```
  
```{r example-metal_run}
#' \dontrun{
#' metal_run(config_file = "config.txt", metal_path = "/path/to/metal_binary")
#' }
```
  
```{r tests-metal_run}
test_that("metal_run works", {
  expect_true(inherits(metal_run, "function")) 
})
```
  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly

fusen::inflate(flat_file = "dev/flat_genomics_functions.Rmd", vignette_name = "Genomics Functions")
```

