# WARNING - Generated by {fusen} from dev/flat_genomics_functions.Rmd: do not edit by hand

#' Run CARMA
#' 
#' This function takes a dataframe containing variants at a locus and performs Bayesian finemapping using CARMA. The function requires a plink-formatted LD reference panel (`bfile`), which will be used to generate a signed LD matrix at the locus.
#'
#' @param df Dataframe containing variants at a locus for finemapping
#' @param snp_col Name of column containing SNP identifiers
#' @param z_col Name of column containing signed Z-scores (relative to effect allele)
#' @param effect_allele_col Name of column containing effect alleles
#' @param bfile Path to plink `bfile` of reference panel that will be used to extract LD
#' @param threads Number of threads (default = 1)
#' @param memory Memory limit (default = 16000 MB)
#' @param plink_bin Path to plink executable
#'
#' @return A dataframe containing the input dataframe, and additional columns denoting which credible set (`CS`) each variant belongs to, as well as the posterior inclusion probability (`PIP`), and an `ld_error` column noting whether there were problems generating the LD matrix that limited fine-mapping.
#' 
#' @export
#' @family {finemapping}
#' @concept genomics
#' @examples
#' \dontrun{
#' run_carma(locus_df, snp_col = SNP, z_col = z, effect_allele_col = allele1)
#' }

run_carma <- function(df, snp_col, z_col, effect_allele_col, bfile, threads = 1, memory = 16000, plink_bin) {
  
  sumstat <- df
  
  ld <- df %>%
    plink_extract_ld(bfile = bfile, snp_col = {{snp_col}}, effect_allele_col = {{effect_allele_col}})
  
  if(is.null(ld)) {
    return(sumstat %>% mutate(ld_error = TRUE))
  }
  
  # if(!is.null(ld$error)) {
  #   sumstat <- sumstat %>%
  #     mutate(ld = ld$error)
  #   return(sumstat)
  # }
  
  cli::cli_alert_info("Running CARMA")
  z.list<-list()
  ld.list<-list()
  lambda.list<-list()
  z.list[[1]] <- sumstat %>% pull({{z_col}})
  ld.list[[1]] <- as.matrix(ld)
  lambda.list[[1]] <- 1
  CARMA.results <- CARMA::CARMA(z.list, ld.list, lambda.list=lambda.list, outlier.switch = TRUE)
  
  sumstat.result <- sumstat %>% mutate(PIP = CARMA.results[[1]]$PIPs, CS = 0)
  if(length(CARMA.results[[1]]$`Credible set`[[2]])!=0){
    for(l in 1:length(CARMA.results[[1]]$`Credible set`[[2]])){
    sumstat.result$CS[CARMA.results[[1]]$`Credible set`[[2]][[l]]]=l
    }
  }
  
  return(sumstat.result)
}
