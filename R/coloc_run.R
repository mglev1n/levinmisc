# WARNING - Generated by {fusen} from /dev/flat_genomics_functions.Rmd: do not edit by hand

#' Run Bayesian enumeration colocalization using Coloc
#' 
#' This function is a wrapper around [coloc::coloc.abf()] that takes a dataframe as input, and performs colocalization under the single-causal-variant assumption. Coloc was described in Giambartolomei et al. (PLOS Genetics 2014; <https://doi.org/10.1371/journal.pgen.1004383>).
#' 
#' @param df Dataframe containing summary statistics at a single locus for two traits in a "long" format, with one row per variant per trait.
#' @param trait_col Column containing trait names
#' @param variant_col Column containing unique variant identifiers (Eg. rsids, chr:pos)
#' @param beta_col Column containing effect estimates
#' @param se_col Column containing standard errors
#' @param samplesize_col Column containing sample sizes
#' @param maf_col Column containing minor allele frequencies
#' @param type_col Column containing the type of each trait ("quant" for quantitative traits, "cc" for binary traits)
#' @param case_prop_col Column containing the proportion of cases for case control studies; this column is ignored for quantitative traits
#' @param p1 Prior probability a SNP is associated with trait 1, default 1e-4
#' @param p2 Prior probability a SNP is associated with trait 2, default 1e-4
#' @param p12 Prior probability a SNP is associated with both traits, default 1e-5
#' @param ... Arguments passed to [coloc::coloc.abf()]
#'
#' @return A list containing coloc results.
#' - `summary` is a named vector containing the number of snps, and the posterior probabilities of the 5 colocalization hypotheses
#' - `results` is an annotated version of the input data containing log approximate Bayes Factors and posterior probability of each SNP being causal if H4 is true.
#' 
#' @concept genomics
#' @family {colocalization}
#' @export

#' @examples
#' \dontrun{
#' coloc_run(locus_df)
#' }
coloc_run <- function(df, trait_col = trait, variant_col = rsid, beta_col = beta, se_col = se, samplesize_col = samplesize, maf_col = maf, type_col = type, case_prop_col = case_prop, p1 = 1e-4, p2 = 1e-4, p12 = 1e-5, ...) {
  
df <- df %>% 
    select(trait = {{trait_col}}, maf = {{maf_col}}, type = {{type_col}}, variant_id = {{variant_col}}, beta = {{beta_col}}, se = {{se_col}}, samplesize = {{samplesize_col}}, case_prop = {{case_prop_col}}) %>%
    add_count(variant_id) %>%
    filter(n == 2)
  
  trait_dfs <- df %>%
    distinct(trait)
  
  if(nrow(trait_dfs) != 2) {
    cli::cli_abort("The input dataframe must contain only two traits")
  }
  
  trait1 <- df %>%
    filter(trait == trait_dfs$trait[1]) %>%
    distinct(variant_id, .keep_all = TRUE)
  
  trait2 <- df %>%
    filter(trait == trait_dfs$trait[2]) %>%
    distinct(variant_id, .keep_all = TRUE)
  
  trait1_dataset <- list(beta = trait1$beta, #If log_OR column is full of NAs then use beta column instead
                          varbeta = trait1$se^2,
                          # pvalues = trait1$pval,
                          type = unique(trait1$type), 
                          snp = trait1$variant_id,
                          N = trait1$samplesize,
                          # {if(unique(trait1$type) == "cc") {s = trait1$case_prop[1]}},
                          MAF = trait1$maf)
  
  trait2_dataset <- list(beta = trait2$beta, #If log_OR column is full of NAs then use beta column instead
                          varbeta = trait2$se^2,
                          # pvalues = trait2$pval,
                          type = unique(trait2$type), 
                          snp = trait2$variant_id,
                          N = trait2$samplesize,
                         # {if(unique(trait2$type) == "cc") {s = trait1$case_prop[2]}},
                          MAF = trait2$maf)
  
  suppressWarnings(coloc_res <- coloc::coloc.abf(dataset1 = trait1_dataset, dataset2 = trait2_dataset, p1, p2, p12, ...))
  return(coloc_res)
}
